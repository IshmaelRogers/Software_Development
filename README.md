# Ishmael Rogers
# Robotics Software Engineer 
# Infinitely Deep Robotics Group
# Software Devlopment 
# 2019 




Software Processes model 
---
How should we put activities together to bring a software to life. Determining the order and transition criteria. 


# * Waterfall 

1. Software concept 
2. Requirements analysis 
3. Architectural design 
4. Detailed design 
5. Coding and debugging 
6. System testing 

Advantage - find errors early
Disadvantage - lack of flexiblity 

NOTE: Less than ideal for real worl projects 

# * Spiral - a way of going through each face in an iterative way to learn more about the software

1. Determine objects 
2. Identify and resolve risks
3. Development and Tests 
4. Plan the next iteration 
5. Review

Advantage 

1. risk reduction 
2. Functionality can be added
3. Software is produced early

Disadvntage 

1. Risk analysis requires specific expertise
2. Highly complex and costly to implement


* Agile - A group of Software development methods that are based on iterative and c=incremental development 

TTD
---

1. Red phase - Write a test that fails 
2. Green phase - Make enough code for it pass
3. Refactoring - improve code quality 

Extreme programming 


# * RUP/USP (Unified Software Process) -

1. Business modeling 
2. Requirements 
3. Analysis and design 
4. Implementation
5. Test 
6. Deployment 



# * Evolutionary prototyping - start at parts that are well understood.

1. concept 
2. Design and implement a prototype 
3. Refine prototype until acceptable 
4. Complete and release prototype

Advantage 

1. Immediate feedback

Disadvantage 

1. Difficult to plan


Choosing a software process model
---

1. Requirements understanding 
2. Expected lifetime 
3. Risk 
4. Schedule constraints 
5. Interaction with management/customers
6. Expertise 

Lifecycle Documents 

1. IEE Documents Definition
2. Light-weight documents 


https://www.udacity.com/wiki/sdp/projects#docs

Classic Mistakes 









Software Phases
---

* Requirements engineering - the field that deals with establishing needs of stakebholders to be solved by the software. 
  1. Cost of life correlation (cost of error vs phase it is found) 

  Collecting requirements 

  1. Elicitation 

  2. Analysis 

  3. Specification 

  4. Validation 

  5. Management 




* Design - software requirements are analyzed to produce description of the internal structure and orgnanization of the system.

# Design Activities:                Design products
J (high level to low level)

1. Architectural Design          System structure
2. Abstract specification        Software specification
3. Interface Design 			 Interface Specification 
4. Component Design 		     Component Specification 
5. Data Structure 				 Data structure specificatiin 
6. Algorithm design 			 Algorithm Specification 



* Implementation - create a software systems

4 pillars

1. Reduce complexitiy 
2. Anticipation of diversity 
3. Structuring for validation (design for testablity)
4. Use of external standards *(create internal standards)*






* Verify and validate - checks if software meets its specification and


Validation determines built the right system 

Verification did we build the system righ 
 


* Maintenance - sustains the software products as it evolves throughout it's life cycles

1. bug reports - corrective maintenance 
2. feature changes - perfective maintenance 
3. Enviornment changes - adaptive maintenance 

NOTE: Regression testing causes maintence to be costly



Tools of the trade 
---

* IDE
* VCS
* Coverage and verification tools

Lifecycle Models 

- A sequence of decisions that determine the history of your software.

What should I do next?

How long should I do it for? 

Which model is good for the situation ahead

Small projects are usually appropriate for agile 

Large projects require a more rigorous approach 

 Multiple lifecycles are usually necessary. 

 Traditional Software Phases
 ---




Advantages vs Disadvantages

Mistakes in software engineering

Fundamental 
